rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Locations collection
    match /locations/{locationId} {
      // Anyone can read locations
      allow read: if true;

      // Only allow creation with required fields
      allow create: if isValidLocation(request.resource.data);

      // Only allow updates to aggregation fields (from rating submissions)
      allow update: if isAggregationUpdate(request.resource.data, resource.data);

      // No deletes from clients
      allow delete: if false;

      // Ratings subcollection
      match /ratings/{ratingId} {
        // Anyone can read ratings
        allow read: if true;

        // Allow creating a rating with a valid userId and structure
        allow create: if isValidRating(request.resource.data);

        // Allow updating only your own rating
        allow update: if request.resource.data.userId == resource.data.userId
                       && isValidRating(request.resource.data);

        // No deletes from clients
        allow delete: if false;
      }
    }

    // Helper: validate location document structure
    function isValidLocation(data) {
      return data.keys().hasAll(['name', 'category', 'city', 'coordinates'])
        && data.name is string
        && data.name.size() > 0
        && data.name.size() <= 200
        && data.category is string
        && data.city is string
        && data.coordinates is map
        && data.coordinates.keys().hasAll(['lat', 'lng'])
        && data.coordinates.lat is number
        && data.coordinates.lng is number;
    }

    // Helper: only allow updating aggregation fields, not core location data
    function isAggregationUpdate(newData, oldData) {
      return newData.name == oldData.name
        && newData.category == oldData.category
        && newData.city == oldData.city
        && newData.coordinates == oldData.coordinates;
    }

    // Helper: validate rating document structure
    function isValidRating(data) {
      return data.keys().hasAll(['userId', 'ageGroup', 'pairs', 'timestamp'])
        && data.userId is string
        && data.userId.size() > 0
        && data.ageGroup is string
        && data.ageGroup in ['18-22', '23-28', '29-35', '36+']
        && data.pairs is list
        && data.pairs.size() >= 1
        && data.pairs.size() <= 3;
    }

    // Deny all other collections
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
